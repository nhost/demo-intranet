schema {
	query: query_root
	mutation: mutation_root
	subscription: subscription_root
}

"""
whether this query should be cached (Hasura Cloud only)
"""
directive @cached(
	"""
	refresh the cache entry
	"""
	refresh: Boolean! = false
	"""
	measured in seconds
	"""
	ttl: Int! = 60
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
	_eq: Boolean
	_gt: Boolean
	_gte: Boolean
	_in: [Boolean!]
	_is_null: Boolean
	_lt: Boolean
	_lte: Boolean
	_neq: Boolean
	_nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
	_eq: Int
	_gt: Int
	_gte: Int
	_in: [Int!]
	_is_null: Boolean
	_lt: Int
	_lte: Int
	_neq: Int
	_nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
	_eq: String
	_gt: String
	_gte: String
	"""
	does the column match the given case-insensitive pattern
	"""
	_ilike: String
	_in: [String!]
	"""
	does the column match the given POSIX regular expression, case insensitive
	"""
	_iregex: String
	_is_null: Boolean
	"""
	does the column match the given pattern
	"""
	_like: String
	_lt: String
	_lte: String
	_neq: String
	"""
	does the column NOT match the given case-insensitive pattern
	"""
	_nilike: String
	_nin: [String!]
	"""
	does the column NOT match the given POSIX regular expression, case insensitive
	"""
	_niregex: String
	"""
	does the column NOT match the given pattern
	"""
	_nlike: String
	"""
	does the column NOT match the given POSIX regular expression, case sensitive
	"""
	_nregex: String
	"""
	does the column NOT match the given SQL regular expression
	"""
	_nsimilar: String
	"""
	does the column match the given POSIX regular expression, case sensitive
	"""
	_regex: String
	"""
	does the column match the given SQL regular expression
	"""
	_similar: String
}

enum authRefreshTokenTypes_enum {
	"""
	Personal access token
	"""
	pat
	"""
	Regular refresh token
	"""
	regular
}

"""
Boolean expression to compare columns of type "authRefreshTokenTypes_enum". All fields are combined with logical 'AND'.
"""
input authRefreshTokenTypes_enum_comparison_exp {
	_eq: authRefreshTokenTypes_enum
	_in: [authRefreshTokenTypes_enum!]
	_is_null: Boolean
	_neq: authRefreshTokenTypes_enum
	_nin: [authRefreshTokenTypes_enum!]
}

"""
User refresh tokens. Hasura auth uses them to rotate new access tokens as long as the refresh token is not expired. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authRefreshTokens {
	createdAt: timestamptz!
	expiresAt: timestamptz!
	id: uuid!
	metadata(
		"""
		JSON select path
		"""
		path: String
	): jsonb
	type: authRefreshTokenTypes_enum!
	"""
	An object relationship
	"""
	user: users!
	userId: uuid!
}

"""
order by aggregate values of table "auth.refresh_tokens"
"""
input authRefreshTokens_aggregate_order_by {
	count: order_by
	max: authRefreshTokens_max_order_by
	min: authRefreshTokens_min_order_by
}

"""
Boolean expression to filter rows from the table "auth.refresh_tokens". All fields are combined with a logical 'AND'.
"""
input authRefreshTokens_bool_exp {
	_and: [authRefreshTokens_bool_exp!]
	_not: authRefreshTokens_bool_exp
	_or: [authRefreshTokens_bool_exp!]
	createdAt: timestamptz_comparison_exp
	expiresAt: timestamptz_comparison_exp
	id: uuid_comparison_exp
	metadata: jsonb_comparison_exp
	type: authRefreshTokenTypes_enum_comparison_exp
	user: users_bool_exp
	userId: uuid_comparison_exp
}

"""
order by max() on columns of table "auth.refresh_tokens"
"""
input authRefreshTokens_max_order_by {
	createdAt: order_by
	expiresAt: order_by
	id: order_by
	userId: order_by
}

"""
order by min() on columns of table "auth.refresh_tokens"
"""
input authRefreshTokens_min_order_by {
	createdAt: order_by
	expiresAt: order_by
	id: order_by
	userId: order_by
}

"""
response of any mutation on the table "auth.refresh_tokens"
"""
type authRefreshTokens_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!
	"""
	data from the rows affected by the mutation
	"""
	returning: [authRefreshTokens!]!
}

"""
Ordering options when selecting data from "auth.refresh_tokens".
"""
input authRefreshTokens_order_by {
	createdAt: order_by
	expiresAt: order_by
	id: order_by
	metadata: order_by
	type: order_by
	user: users_order_by
	userId: order_by
}

"""
select columns of table "auth.refresh_tokens"
"""
enum authRefreshTokens_select_column {
	"""
	column name
	"""
	createdAt
	"""
	column name
	"""
	expiresAt
	"""
	column name
	"""
	id
	"""
	column name
	"""
	metadata
	"""
	column name
	"""
	type
	"""
	column name
	"""
	userId
}

"""
Streaming cursor of the table "authRefreshTokens"
"""
input authRefreshTokens_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: authRefreshTokens_stream_cursor_value_input!
	"""
	cursor ordering
	"""
	ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input authRefreshTokens_stream_cursor_value_input {
	createdAt: timestamptz
	expiresAt: timestamptz
	id: uuid
	metadata: jsonb
	type: authRefreshTokenTypes_enum
	userId: uuid
}

"""
User webauthn security keys. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authUserSecurityKeys {
	counter: bigint!
	credentialId: String!
	credentialPublicKey: bytea
	id: uuid!
	nickname: String
	transports: String!
	"""
	An object relationship
	"""
	user: users!
	userId: uuid!
}

"""
order by aggregate values of table "auth.user_security_keys"
"""
input authUserSecurityKeys_aggregate_order_by {
	avg: authUserSecurityKeys_avg_order_by
	count: order_by
	max: authUserSecurityKeys_max_order_by
	min: authUserSecurityKeys_min_order_by
	stddev: authUserSecurityKeys_stddev_order_by
	stddev_pop: authUserSecurityKeys_stddev_pop_order_by
	stddev_samp: authUserSecurityKeys_stddev_samp_order_by
	sum: authUserSecurityKeys_sum_order_by
	var_pop: authUserSecurityKeys_var_pop_order_by
	var_samp: authUserSecurityKeys_var_samp_order_by
	variance: authUserSecurityKeys_variance_order_by
}

"""
order by avg() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_avg_order_by {
	counter: order_by
}

"""
Boolean expression to filter rows from the table "auth.user_security_keys". All fields are combined with a logical 'AND'.
"""
input authUserSecurityKeys_bool_exp {
	_and: [authUserSecurityKeys_bool_exp!]
	_not: authUserSecurityKeys_bool_exp
	_or: [authUserSecurityKeys_bool_exp!]
	counter: bigint_comparison_exp
	credentialId: String_comparison_exp
	credentialPublicKey: bytea_comparison_exp
	id: uuid_comparison_exp
	nickname: String_comparison_exp
	transports: String_comparison_exp
	user: users_bool_exp
	userId: uuid_comparison_exp
}

"""
order by max() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_max_order_by {
	counter: order_by
	credentialId: order_by
	id: order_by
	nickname: order_by
	transports: order_by
	userId: order_by
}

"""
order by min() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_min_order_by {
	counter: order_by
	credentialId: order_by
	id: order_by
	nickname: order_by
	transports: order_by
	userId: order_by
}

"""
response of any mutation on the table "auth.user_security_keys"
"""
type authUserSecurityKeys_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!
	"""
	data from the rows affected by the mutation
	"""
	returning: [authUserSecurityKeys!]!
}

"""
Ordering options when selecting data from "auth.user_security_keys".
"""
input authUserSecurityKeys_order_by {
	counter: order_by
	credentialId: order_by
	credentialPublicKey: order_by
	id: order_by
	nickname: order_by
	transports: order_by
	user: users_order_by
	userId: order_by
}

"""
select columns of table "auth.user_security_keys"
"""
enum authUserSecurityKeys_select_column {
	"""
	column name
	"""
	counter
	"""
	column name
	"""
	credentialId
	"""
	column name
	"""
	credentialPublicKey
	"""
	column name
	"""
	id
	"""
	column name
	"""
	nickname
	"""
	column name
	"""
	transports
	"""
	column name
	"""
	userId
}

"""
order by stddev() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_stddev_order_by {
	counter: order_by
}

"""
order by stddev_pop() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_stddev_pop_order_by {
	counter: order_by
}

"""
order by stddev_samp() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_stddev_samp_order_by {
	counter: order_by
}

"""
Streaming cursor of the table "authUserSecurityKeys"
"""
input authUserSecurityKeys_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: authUserSecurityKeys_stream_cursor_value_input!
	"""
	cursor ordering
	"""
	ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input authUserSecurityKeys_stream_cursor_value_input {
	counter: bigint
	credentialId: String
	credentialPublicKey: bytea
	id: uuid
	nickname: String
	transports: String
	userId: uuid
}

"""
order by sum() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_sum_order_by {
	counter: order_by
}

"""
order by var_pop() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_var_pop_order_by {
	counter: order_by
}

"""
order by var_samp() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_var_samp_order_by {
	counter: order_by
}

"""
order by variance() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_variance_order_by {
	counter: order_by
}

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
	_eq: bigint
	_gt: bigint
	_gte: bigint
	_in: [bigint!]
	_is_null: Boolean
	_lt: bigint
	_lte: bigint
	_neq: bigint
	_nin: [bigint!]
}

scalar bytea

"""
Boolean expression to compare columns of type "bytea". All fields are combined with logical 'AND'.
"""
input bytea_comparison_exp {
	_eq: bytea
	_gt: bytea
	_gte: bytea
	_in: [bytea!]
	_is_null: Boolean
	_lt: bytea
	_lte: bytea
	_neq: bytea
	_nin: [bytea!]
}

scalar citext

"""
Boolean expression to compare columns of type "citext". All fields are combined with logical 'AND'.
"""
input citext_comparison_exp {
	_eq: citext
	_gt: citext
	_gte: citext
	"""
	does the column match the given case-insensitive pattern
	"""
	_ilike: citext
	_in: [citext!]
	"""
	does the column match the given POSIX regular expression, case insensitive
	"""
	_iregex: citext
	_is_null: Boolean
	"""
	does the column match the given pattern
	"""
	_like: citext
	_lt: citext
	_lte: citext
	_neq: citext
	"""
	does the column NOT match the given case-insensitive pattern
	"""
	_nilike: citext
	_nin: [citext!]
	"""
	does the column NOT match the given POSIX regular expression, case insensitive
	"""
	_niregex: citext
	"""
	does the column NOT match the given pattern
	"""
	_nlike: citext
	"""
	does the column NOT match the given POSIX regular expression, case sensitive
	"""
	_nregex: citext
	"""
	does the column NOT match the given SQL regular expression
	"""
	_nsimilar: citext
	"""
	does the column match the given POSIX regular expression, case sensitive
	"""
	_regex: citext
	"""
	does the column match the given SQL regular expression
	"""
	_similar: citext
}

"""
ordering argument of a cursor
"""
enum cursor_ordering {
	"""
	ascending ordering of the cursor
	"""
	ASC
	"""
	descending ordering of the cursor
	"""
	DESC
}

"""
columns and relationships of "department_files"
"""
type department_files {
	"""
	An object relationship
	"""
	department: departments!
	department_id: uuid!
	"""
	An object relationship
	"""
	file: files!
	file_id: uuid!
	id: uuid!
}

"""
order by aggregate values of table "department_files"
"""
input department_files_aggregate_order_by {
	count: order_by
	max: department_files_max_order_by
	min: department_files_min_order_by
}

"""
Boolean expression to filter rows from the table "department_files". All fields are combined with a logical 'AND'.
"""
input department_files_bool_exp {
	_and: [department_files_bool_exp!]
	_not: department_files_bool_exp
	_or: [department_files_bool_exp!]
	department: departments_bool_exp
	department_id: uuid_comparison_exp
	file: files_bool_exp
	file_id: uuid_comparison_exp
	id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "department_files"
"""
enum department_files_constraint {
	"""
	unique or primary key constraint on columns "id"
	"""
	department_files_pkey
}

"""
input type for inserting data into table "department_files"
"""
input department_files_insert_input {
	department_id: uuid
	file: files_obj_rel_insert_input
	file_id: uuid
}

"""
order by max() on columns of table "department_files"
"""
input department_files_max_order_by {
	department_id: order_by
	file_id: order_by
	id: order_by
}

"""
order by min() on columns of table "department_files"
"""
input department_files_min_order_by {
	department_id: order_by
	file_id: order_by
	id: order_by
}

"""
response of any mutation on the table "department_files"
"""
type department_files_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!
	"""
	data from the rows affected by the mutation
	"""
	returning: [department_files!]!
}

"""
input type for inserting object relation for remote table "department_files"
"""
input department_files_obj_rel_insert_input {
	data: department_files_insert_input!
	"""
	upsert condition
	"""
	on_conflict: department_files_on_conflict
}

"""
on_conflict condition type for table "department_files"
"""
input department_files_on_conflict {
	constraint: department_files_constraint!
	update_columns: [department_files_update_column!]! = []
	where: department_files_bool_exp
}

"""
Ordering options when selecting data from "department_files".
"""
input department_files_order_by {
	department: departments_order_by
	department_id: order_by
	file: files_order_by
	file_id: order_by
	id: order_by
}

"""
select columns of table "department_files"
"""
enum department_files_select_column {
	"""
	column name
	"""
	department_id
	"""
	column name
	"""
	file_id
	"""
	column name
	"""
	id
}

"""
Streaming cursor of the table "department_files"
"""
input department_files_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: department_files_stream_cursor_value_input!
	"""
	cursor ordering
	"""
	ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input department_files_stream_cursor_value_input {
	department_id: uuid
	file_id: uuid
	id: uuid
}

"""
placeholder for update columns of table "department_files" (current role has no relevant permissions)
"""
enum department_files_update_column {
	"""
	placeholder (do not use)
	"""
	_PLACEHOLDER
}

"""
columns and relationships of "department_roles"
"""
type department_roles {
	comment: String
	value: String!
}

"""
Boolean expression to filter rows from the table "department_roles". All fields are combined with a logical 'AND'.
"""
input department_roles_bool_exp {
	_and: [department_roles_bool_exp!]
	_not: department_roles_bool_exp
	_or: [department_roles_bool_exp!]
	comment: String_comparison_exp
	value: String_comparison_exp
}

enum department_roles_enum {
	"""
	Department manager
	"""
	manager
	"""
	Regular department member
	"""
	member
}

"""
Boolean expression to compare columns of type "department_roles_enum". All fields are combined with logical 'AND'.
"""
input department_roles_enum_comparison_exp {
	_eq: department_roles_enum
	_in: [department_roles_enum!]
	_is_null: Boolean
	_neq: department_roles_enum
	_nin: [department_roles_enum!]
}

"""
Ordering options when selecting data from "department_roles".
"""
input department_roles_order_by {
	comment: order_by
	value: order_by
}

"""
select columns of table "department_roles"
"""
enum department_roles_select_column {
	"""
	column name
	"""
	comment
	"""
	column name
	"""
	value
}

"""
Streaming cursor of the table "department_roles"
"""
input department_roles_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: department_roles_stream_cursor_value_input!
	"""
	cursor ordering
	"""
	ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input department_roles_stream_cursor_value_input {
	comment: String
	value: String
}

"""
columns and relationships of "departments"
"""
type departments {
	budget: numeric
	created_at: timestamptz!
	description: String
	"""
	An array relationship
	"""
	employees(
		"""
		distinct select on columns
		"""
		distinct_on: [user_departments_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [user_departments_order_by!]
		"""
		filter the rows returned
		"""
		where: user_departments_bool_exp
	): [user_departments!]!
	"""
	An array relationship
	"""
	files(
		"""
		distinct select on columns
		"""
		distinct_on: [department_files_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [department_files_order_by!]
		"""
		filter the rows returned
		"""
		where: department_files_bool_exp
	): [department_files!]!
	id: uuid!
	"""
	An array relationship
	"""
	kb_entry_departments(
		"""
		distinct select on columns
		"""
		distinct_on: [kb_entry_departments_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [kb_entry_departments_order_by!]
		"""
		filter the rows returned
		"""
		where: kb_entry_departments_bool_exp
	): [kb_entry_departments!]!
	name: String!
	updated_at: timestamptz!
}

"""
Boolean expression to filter rows from the table "departments". All fields are combined with a logical 'AND'.
"""
input departments_bool_exp {
	_and: [departments_bool_exp!]
	_not: departments_bool_exp
	_or: [departments_bool_exp!]
	budget: numeric_comparison_exp
	created_at: timestamptz_comparison_exp
	description: String_comparison_exp
	employees: user_departments_bool_exp
	files: department_files_bool_exp
	id: uuid_comparison_exp
	kb_entry_departments: kb_entry_departments_bool_exp
	name: String_comparison_exp
	updated_at: timestamptz_comparison_exp
}

"""
input type for incrementing numeric columns in table "departments"
"""
input departments_inc_input {
	budget: numeric
}

"""
response of any mutation on the table "departments"
"""
type departments_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!
	"""
	data from the rows affected by the mutation
	"""
	returning: [departments!]!
}

"""
Ordering options when selecting data from "departments".
"""
input departments_order_by {
	budget: order_by
	created_at: order_by
	description: order_by
	employees_aggregate: user_departments_aggregate_order_by
	files_aggregate: department_files_aggregate_order_by
	id: order_by
	kb_entry_departments_aggregate: kb_entry_departments_aggregate_order_by
	name: order_by
	updated_at: order_by
}

"""
primary key columns input for table: departments
"""
input departments_pk_columns_input {
	id: uuid!
}

"""
select columns of table "departments"
"""
enum departments_select_column {
	"""
	column name
	"""
	budget
	"""
	column name
	"""
	created_at
	"""
	column name
	"""
	description
	"""
	column name
	"""
	id
	"""
	column name
	"""
	name
	"""
	column name
	"""
	updated_at
}

"""
input type for updating data in table "departments"
"""
input departments_set_input {
	budget: numeric
	created_at: timestamptz
	description: String
	id: uuid
	name: String
	updated_at: timestamptz
}

"""
Streaming cursor of the table "departments"
"""
input departments_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: departments_stream_cursor_value_input!
	"""
	cursor ordering
	"""
	ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input departments_stream_cursor_value_input {
	budget: numeric
	created_at: timestamptz
	description: String
	id: uuid
	name: String
	updated_at: timestamptz
}

input departments_updates {
	"""
	increments the numeric columns with given value of the filtered values
	"""
	_inc: departments_inc_input
	"""
	sets the columns of the filtered rows to the given values
	"""
	_set: departments_set_input
	"""
	filter the rows which have to be updated
	"""
	where: departments_bool_exp!
}

"""
columns and relationships of "storage.files"
"""
type files {
	bucketId: String!
	createdAt: timestamptz!
	"""
	An object relationship
	"""
	department_file: department_files
	etag: String
	id: uuid!
	isUploaded: Boolean
	metadata(
		"""
		JSON select path
		"""
		path: String
	): jsonb
	mimeType: String
	name: String
	size: Int
	updatedAt: timestamptz!
	uploadedByUserId: uuid
}

"""
Boolean expression to filter rows from the table "storage.files". All fields are combined with a logical 'AND'.
"""
input files_bool_exp {
	_and: [files_bool_exp!]
	_not: files_bool_exp
	_or: [files_bool_exp!]
	bucketId: String_comparison_exp
	createdAt: timestamptz_comparison_exp
	department_file: department_files_bool_exp
	etag: String_comparison_exp
	id: uuid_comparison_exp
	isUploaded: Boolean_comparison_exp
	metadata: jsonb_comparison_exp
	mimeType: String_comparison_exp
	name: String_comparison_exp
	size: Int_comparison_exp
	updatedAt: timestamptz_comparison_exp
	uploadedByUserId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "storage.files"
"""
enum files_constraint {
	"""
	unique or primary key constraint on columns "id"
	"""
	files_pkey
}

"""
input type for inserting data into table "storage.files"
"""
input files_insert_input {
	bucketId: String
	createdAt: timestamptz
	department_file: department_files_obj_rel_insert_input
	etag: String
	id: uuid
	isUploaded: Boolean
	metadata: jsonb
	mimeType: String
	name: String
	size: Int
	updatedAt: timestamptz
}

"""
response of any mutation on the table "storage.files"
"""
type files_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!
	"""
	data from the rows affected by the mutation
	"""
	returning: [files!]!
}

"""
input type for inserting object relation for remote table "storage.files"
"""
input files_obj_rel_insert_input {
	data: files_insert_input!
	"""
	upsert condition
	"""
	on_conflict: files_on_conflict
}

"""
on_conflict condition type for table "storage.files"
"""
input files_on_conflict {
	constraint: files_constraint!
	update_columns: [files_update_column!]! = []
	where: files_bool_exp
}

"""
Ordering options when selecting data from "storage.files".
"""
input files_order_by {
	bucketId: order_by
	createdAt: order_by
	department_file: department_files_order_by
	etag: order_by
	id: order_by
	isUploaded: order_by
	metadata: order_by
	mimeType: order_by
	name: order_by
	size: order_by
	updatedAt: order_by
	uploadedByUserId: order_by
}

"""
select columns of table "storage.files"
"""
enum files_select_column {
	"""
	column name
	"""
	bucketId
	"""
	column name
	"""
	createdAt
	"""
	column name
	"""
	etag
	"""
	column name
	"""
	id
	"""
	column name
	"""
	isUploaded
	"""
	column name
	"""
	metadata
	"""
	column name
	"""
	mimeType
	"""
	column name
	"""
	name
	"""
	column name
	"""
	size
	"""
	column name
	"""
	updatedAt
	"""
	column name
	"""
	uploadedByUserId
}

"""
Streaming cursor of the table "files"
"""
input files_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: files_stream_cursor_value_input!
	"""
	cursor ordering
	"""
	ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input files_stream_cursor_value_input {
	bucketId: String
	createdAt: timestamptz
	etag: String
	id: uuid
	isUploaded: Boolean
	metadata: jsonb
	mimeType: String
	name: String
	size: Int
	updatedAt: timestamptz
	uploadedByUserId: uuid
}

"""
placeholder for update columns of table "storage.files" (current role has no relevant permissions)
"""
enum files_update_column {
	"""
	placeholder (do not use)
	"""
	_PLACEHOLDER
}

scalar jsonb

input jsonb_cast_exp {
	String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
	_cast: jsonb_cast_exp
	"""
	is the column contained in the given json value
	"""
	_contained_in: jsonb
	"""
	does the column contain the given json value at the top level
	"""
	_contains: jsonb
	_eq: jsonb
	_gt: jsonb
	_gte: jsonb
	"""
	does the string exist as a top-level key in the column
	"""
	_has_key: String
	"""
	do all of these strings exist as top-level keys in the column
	"""
	_has_keys_all: [String!]
	"""
	do any of these strings exist as top-level keys in the column
	"""
	_has_keys_any: [String!]
	_in: [jsonb!]
	_is_null: Boolean
	_lt: jsonb
	_lte: jsonb
	_neq: jsonb
	_nin: [jsonb!]
}

"""
columns and relationships of "kb_entries"
"""
type kb_entries {
	content: String!
	created_at: timestamptz!
	id: uuid!
	"""
	An array relationship
	"""
	kb_entry_departments(
		"""
		distinct select on columns
		"""
		distinct_on: [kb_entry_departments_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [kb_entry_departments_order_by!]
		"""
		filter the rows returned
		"""
		where: kb_entry_departments_bool_exp
	): [kb_entry_departments!]!
	summary: String
	title: String!
	updated_at: timestamptz!
	"""
	An object relationship
	"""
	uploader: users!
	uploader_id: uuid!
}

"""
Boolean expression to filter rows from the table "kb_entries". All fields are combined with a logical 'AND'.
"""
input kb_entries_bool_exp {
	_and: [kb_entries_bool_exp!]
	_not: kb_entries_bool_exp
	_or: [kb_entries_bool_exp!]
	content: String_comparison_exp
	created_at: timestamptz_comparison_exp
	id: uuid_comparison_exp
	kb_entry_departments: kb_entry_departments_bool_exp
	summary: String_comparison_exp
	title: String_comparison_exp
	updated_at: timestamptz_comparison_exp
	uploader: users_bool_exp
	uploader_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "kb_entries"
"""
enum kb_entries_constraint {
	"""
	unique or primary key constraint on columns "id"
	"""
	kb_entries_pkey
}

"""
input type for inserting data into table "kb_entries"
"""
input kb_entries_insert_input {
	content: String
	kb_entry_departments: kb_entry_departments_arr_rel_insert_input
	summary: String
	title: String
}

"""
response of any mutation on the table "kb_entries"
"""
type kb_entries_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!
	"""
	data from the rows affected by the mutation
	"""
	returning: [kb_entries!]!
}

"""
input type for inserting object relation for remote table "kb_entries"
"""
input kb_entries_obj_rel_insert_input {
	data: kb_entries_insert_input!
	"""
	upsert condition
	"""
	on_conflict: kb_entries_on_conflict
}

"""
on_conflict condition type for table "kb_entries"
"""
input kb_entries_on_conflict {
	constraint: kb_entries_constraint!
	update_columns: [kb_entries_update_column!]! = []
	where: kb_entries_bool_exp
}

"""
Ordering options when selecting data from "kb_entries".
"""
input kb_entries_order_by {
	content: order_by
	created_at: order_by
	id: order_by
	kb_entry_departments_aggregate: kb_entry_departments_aggregate_order_by
	summary: order_by
	title: order_by
	updated_at: order_by
	uploader: users_order_by
	uploader_id: order_by
}

"""
primary key columns input for table: kb_entries
"""
input kb_entries_pk_columns_input {
	id: uuid!
}

"""
select columns of table "kb_entries"
"""
enum kb_entries_select_column {
	"""
	column name
	"""
	content
	"""
	column name
	"""
	created_at
	"""
	column name
	"""
	id
	"""
	column name
	"""
	summary
	"""
	column name
	"""
	title
	"""
	column name
	"""
	updated_at
	"""
	column name
	"""
	uploader_id
}

"""
input type for updating data in table "kb_entries"
"""
input kb_entries_set_input {
	content: String
	summary: String
	title: String
}

"""
Streaming cursor of the table "kb_entries"
"""
input kb_entries_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: kb_entries_stream_cursor_value_input!
	"""
	cursor ordering
	"""
	ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input kb_entries_stream_cursor_value_input {
	content: String
	created_at: timestamptz
	id: uuid
	summary: String
	title: String
	updated_at: timestamptz
	uploader_id: uuid
}

"""
update columns of table "kb_entries"
"""
enum kb_entries_update_column {
	"""
	column name
	"""
	content
	"""
	column name
	"""
	summary
	"""
	column name
	"""
	title
}

input kb_entries_updates {
	"""
	sets the columns of the filtered rows to the given values
	"""
	_set: kb_entries_set_input
	"""
	filter the rows which have to be updated
	"""
	where: kb_entries_bool_exp!
}

"""
columns and relationships of "kb_entry_departments"
"""
type kb_entry_departments {
	"""
	An object relationship
	"""
	department: departments!
	department_id: uuid!
	id: uuid!
	"""
	An object relationship
	"""
	kb_entry: kb_entries!
	kb_entry_id: uuid!
}

"""
order by aggregate values of table "kb_entry_departments"
"""
input kb_entry_departments_aggregate_order_by {
	count: order_by
	max: kb_entry_departments_max_order_by
	min: kb_entry_departments_min_order_by
}

"""
input type for inserting array relation for remote table "kb_entry_departments"
"""
input kb_entry_departments_arr_rel_insert_input {
	data: [kb_entry_departments_insert_input!]!
	"""
	upsert condition
	"""
	on_conflict: kb_entry_departments_on_conflict
}

"""
Boolean expression to filter rows from the table "kb_entry_departments". All fields are combined with a logical 'AND'.
"""
input kb_entry_departments_bool_exp {
	_and: [kb_entry_departments_bool_exp!]
	_not: kb_entry_departments_bool_exp
	_or: [kb_entry_departments_bool_exp!]
	department: departments_bool_exp
	department_id: uuid_comparison_exp
	id: uuid_comparison_exp
	kb_entry: kb_entries_bool_exp
	kb_entry_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "kb_entry_departments"
"""
enum kb_entry_departments_constraint {
	"""
	unique or primary key constraint on columns "kb_entry_id", "department_id"
	"""
	kb_entry_departments_kb_entry_id_department_id_key
	"""
	unique or primary key constraint on columns "id"
	"""
	kb_entry_departments_pkey
}

"""
input type for inserting data into table "kb_entry_departments"
"""
input kb_entry_departments_insert_input {
	department_id: uuid
	kb_entry: kb_entries_obj_rel_insert_input
	kb_entry_id: uuid
}

"""
order by max() on columns of table "kb_entry_departments"
"""
input kb_entry_departments_max_order_by {
	department_id: order_by
	id: order_by
	kb_entry_id: order_by
}

"""
order by min() on columns of table "kb_entry_departments"
"""
input kb_entry_departments_min_order_by {
	department_id: order_by
	id: order_by
	kb_entry_id: order_by
}

"""
response of any mutation on the table "kb_entry_departments"
"""
type kb_entry_departments_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!
	"""
	data from the rows affected by the mutation
	"""
	returning: [kb_entry_departments!]!
}

"""
on_conflict condition type for table "kb_entry_departments"
"""
input kb_entry_departments_on_conflict {
	constraint: kb_entry_departments_constraint!
	update_columns: [kb_entry_departments_update_column!]! = []
	where: kb_entry_departments_bool_exp
}

"""
Ordering options when selecting data from "kb_entry_departments".
"""
input kb_entry_departments_order_by {
	department: departments_order_by
	department_id: order_by
	id: order_by
	kb_entry: kb_entries_order_by
	kb_entry_id: order_by
}

"""
select columns of table "kb_entry_departments"
"""
enum kb_entry_departments_select_column {
	"""
	column name
	"""
	department_id
	"""
	column name
	"""
	id
	"""
	column name
	"""
	kb_entry_id
}

"""
Streaming cursor of the table "kb_entry_departments"
"""
input kb_entry_departments_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: kb_entry_departments_stream_cursor_value_input!
	"""
	cursor ordering
	"""
	ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input kb_entry_departments_stream_cursor_value_input {
	department_id: uuid
	id: uuid
	kb_entry_id: uuid
}

"""
placeholder for update columns of table "kb_entry_departments" (current role has no relevant permissions)
"""
enum kb_entry_departments_update_column {
	"""
	placeholder (do not use)
	"""
	_PLACEHOLDER
}

"""
mutation root
"""
type mutation_root {
	"""
	delete single row from the table: "auth.refresh_tokens"
	"""
	deleteAuthRefreshToken(id: uuid!): authRefreshTokens
	"""
	delete data from the table: "auth.refresh_tokens"
	"""
	deleteAuthRefreshTokens(
		"""
		filter the rows which have to be deleted
		"""
		where: authRefreshTokens_bool_exp!
	): authRefreshTokens_mutation_response
	"""
	delete single row from the table: "auth.user_security_keys"
	"""
	deleteAuthUserSecurityKey(id: uuid!): authUserSecurityKeys
	"""
	delete data from the table: "auth.user_security_keys"
	"""
	deleteAuthUserSecurityKeys(
		"""
		filter the rows which have to be deleted
		"""
		where: authUserSecurityKeys_bool_exp!
	): authUserSecurityKeys_mutation_response
	"""
	delete single row from the table: "storage.files"
	"""
	deleteFile(id: uuid!): files
	"""
	delete data from the table: "storage.files"
	"""
	deleteFiles(
		"""
		filter the rows which have to be deleted
		"""
		where: files_bool_exp!
	): files_mutation_response
	"""
	delete data from the table: "department_files"
	"""
	delete_department_files(
		"""
		filter the rows which have to be deleted
		"""
		where: department_files_bool_exp!
	): department_files_mutation_response
	"""
	delete single row from the table: "department_files"
	"""
	delete_department_files_by_pk(id: uuid!): department_files
	"""
	delete data from the table: "kb_entries"
	"""
	delete_kb_entries(
		"""
		filter the rows which have to be deleted
		"""
		where: kb_entries_bool_exp!
	): kb_entries_mutation_response
	"""
	delete single row from the table: "kb_entries"
	"""
	delete_kb_entries_by_pk(id: uuid!): kb_entries
	"""
	delete data from the table: "kb_entry_departments"
	"""
	delete_kb_entry_departments(
		"""
		filter the rows which have to be deleted
		"""
		where: kb_entry_departments_bool_exp!
	): kb_entry_departments_mutation_response
	"""
	delete single row from the table: "kb_entry_departments"
	"""
	delete_kb_entry_departments_by_pk(id: uuid!): kb_entry_departments
	"""
	delete data from the table: "user_departments"
	"""
	delete_user_departments(
		"""
		filter the rows which have to be deleted
		"""
		where: user_departments_bool_exp!
	): user_departments_mutation_response
	"""
	delete single row from the table: "user_departments"
	"""
	delete_user_departments_by_pk(id: uuid!): user_departments
	"""
	insert a single row into the table: "storage.files"
	"""
	insertFile(
		"""
		the row to be inserted
		"""
		object: files_insert_input!
		"""
		upsert condition
		"""
		on_conflict: files_on_conflict
	): files
	"""
	insert data into the table: "storage.files"
	"""
	insertFiles(
		"""
		the rows to be inserted
		"""
		objects: [files_insert_input!]!
		"""
		upsert condition
		"""
		on_conflict: files_on_conflict
	): files_mutation_response
	"""
	insert data into the table: "department_files"
	"""
	insert_department_files(
		"""
		the rows to be inserted
		"""
		objects: [department_files_insert_input!]!
		"""
		upsert condition
		"""
		on_conflict: department_files_on_conflict
	): department_files_mutation_response
	"""
	insert a single row into the table: "department_files"
	"""
	insert_department_files_one(
		"""
		the row to be inserted
		"""
		object: department_files_insert_input!
		"""
		upsert condition
		"""
		on_conflict: department_files_on_conflict
	): department_files
	"""
	insert data into the table: "kb_entries"
	"""
	insert_kb_entries(
		"""
		the rows to be inserted
		"""
		objects: [kb_entries_insert_input!]!
		"""
		upsert condition
		"""
		on_conflict: kb_entries_on_conflict
	): kb_entries_mutation_response
	"""
	insert a single row into the table: "kb_entries"
	"""
	insert_kb_entries_one(
		"""
		the row to be inserted
		"""
		object: kb_entries_insert_input!
		"""
		upsert condition
		"""
		on_conflict: kb_entries_on_conflict
	): kb_entries
	"""
	insert data into the table: "kb_entry_departments"
	"""
	insert_kb_entry_departments(
		"""
		the rows to be inserted
		"""
		objects: [kb_entry_departments_insert_input!]!
		"""
		upsert condition
		"""
		on_conflict: kb_entry_departments_on_conflict
	): kb_entry_departments_mutation_response
	"""
	insert a single row into the table: "kb_entry_departments"
	"""
	insert_kb_entry_departments_one(
		"""
		the row to be inserted
		"""
		object: kb_entry_departments_insert_input!
		"""
		upsert condition
		"""
		on_conflict: kb_entry_departments_on_conflict
	): kb_entry_departments
	"""
	insert data into the table: "user_departments"
	"""
	insert_user_departments(
		"""
		the rows to be inserted
		"""
		objects: [user_departments_insert_input!]!
		"""
		upsert condition
		"""
		on_conflict: user_departments_on_conflict
	): user_departments_mutation_response
	"""
	insert a single row into the table: "user_departments"
	"""
	insert_user_departments_one(
		"""
		the row to be inserted
		"""
		object: user_departments_insert_input!
		"""
		upsert condition
		"""
		on_conflict: user_departments_on_conflict
	): user_departments
	"""
	update single row of the table: "auth.users"
	"""
	updateUser(
		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: users_set_input
		pk_columns: users_pk_columns_input!
	): users
	"""
	update data of the table: "auth.users"
	"""
	updateUsers(
		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: users_set_input
		"""
		filter the rows which have to be updated
		"""
		where: users_bool_exp!
	): users_mutation_response
	"""
	update data of the table: "departments"
	"""
	update_departments(
		"""
		increments the numeric columns with given value of the filtered values
		"""
		_inc: departments_inc_input
		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: departments_set_input
		"""
		filter the rows which have to be updated
		"""
		where: departments_bool_exp!
	): departments_mutation_response
	"""
	update single row of the table: "departments"
	"""
	update_departments_by_pk(
		"""
		increments the numeric columns with given value of the filtered values
		"""
		_inc: departments_inc_input
		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: departments_set_input
		pk_columns: departments_pk_columns_input!
	): departments
	"""
	update multiples rows of table: "departments"
	"""
	update_departments_many(
		"""
		updates to execute, in order
		"""
		updates: [departments_updates!]!
	): [departments_mutation_response]
	"""
	update data of the table: "kb_entries"
	"""
	update_kb_entries(
		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: kb_entries_set_input
		"""
		filter the rows which have to be updated
		"""
		where: kb_entries_bool_exp!
	): kb_entries_mutation_response
	"""
	update single row of the table: "kb_entries"
	"""
	update_kb_entries_by_pk(
		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: kb_entries_set_input
		pk_columns: kb_entries_pk_columns_input!
	): kb_entries
	"""
	update multiples rows of table: "kb_entries"
	"""
	update_kb_entries_many(
		"""
		updates to execute, in order
		"""
		updates: [kb_entries_updates!]!
	): [kb_entries_mutation_response]
	"""
	update data of the table: "user_departments"
	"""
	update_user_departments(
		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: user_departments_set_input
		"""
		filter the rows which have to be updated
		"""
		where: user_departments_bool_exp!
	): user_departments_mutation_response
	"""
	update single row of the table: "user_departments"
	"""
	update_user_departments_by_pk(
		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: user_departments_set_input
		pk_columns: user_departments_pk_columns_input!
	): user_departments
	"""
	update multiples rows of table: "user_departments"
	"""
	update_user_departments_many(
		"""
		updates to execute, in order
		"""
		updates: [user_departments_updates!]!
	): [user_departments_mutation_response]
	"""
	update multiples rows of table: "auth.users"
	"""
	update_users_many(
		"""
		updates to execute, in order
		"""
		updates: [users_updates!]!
	): [users_mutation_response]
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
	_eq: numeric
	_gt: numeric
	_gte: numeric
	_in: [numeric!]
	_is_null: Boolean
	_lt: numeric
	_lte: numeric
	_neq: numeric
	_nin: [numeric!]
}

"""
column ordering options
"""
enum order_by {
	"""
	in ascending order, nulls last
	"""
	asc
	"""
	in ascending order, nulls first
	"""
	asc_nulls_first
	"""
	in ascending order, nulls last
	"""
	asc_nulls_last
	"""
	in descending order, nulls first
	"""
	desc
	"""
	in descending order, nulls first
	"""
	desc_nulls_first
	"""
	in descending order, nulls last
	"""
	desc_nulls_last
}

type query_root {
	"""
	fetch data from the table: "auth.refresh_tokens" using primary key columns
	"""
	authRefreshToken(id: uuid!): authRefreshTokens
	"""
	fetch data from the table: "auth.refresh_tokens"
	"""
	authRefreshTokens(
		"""
		distinct select on columns
		"""
		distinct_on: [authRefreshTokens_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [authRefreshTokens_order_by!]
		"""
		filter the rows returned
		"""
		where: authRefreshTokens_bool_exp
	): [authRefreshTokens!]!
	"""
	fetch data from the table: "auth.user_security_keys" using primary key columns
	"""
	authUserSecurityKey(id: uuid!): authUserSecurityKeys
	"""
	fetch data from the table: "auth.user_security_keys"
	"""
	authUserSecurityKeys(
		"""
		distinct select on columns
		"""
		distinct_on: [authUserSecurityKeys_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [authUserSecurityKeys_order_by!]
		"""
		filter the rows returned
		"""
		where: authUserSecurityKeys_bool_exp
	): [authUserSecurityKeys!]!
	"""
	fetch data from the table: "department_files"
	"""
	department_files(
		"""
		distinct select on columns
		"""
		distinct_on: [department_files_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [department_files_order_by!]
		"""
		filter the rows returned
		"""
		where: department_files_bool_exp
	): [department_files!]!
	"""
	fetch data from the table: "department_files" using primary key columns
	"""
	department_files_by_pk(id: uuid!): department_files
	"""
	fetch data from the table: "department_roles"
	"""
	department_roles(
		"""
		distinct select on columns
		"""
		distinct_on: [department_roles_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [department_roles_order_by!]
		"""
		filter the rows returned
		"""
		where: department_roles_bool_exp
	): [department_roles!]!
	"""
	fetch data from the table: "department_roles" using primary key columns
	"""
	department_roles_by_pk(value: String!): department_roles
	"""
	fetch data from the table: "departments"
	"""
	departments(
		"""
		distinct select on columns
		"""
		distinct_on: [departments_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [departments_order_by!]
		"""
		filter the rows returned
		"""
		where: departments_bool_exp
	): [departments!]!
	"""
	fetch data from the table: "departments" using primary key columns
	"""
	departments_by_pk(id: uuid!): departments
	"""
	fetch data from the table: "storage.files" using primary key columns
	"""
	file(id: uuid!): files
	"""
	fetch data from the table: "storage.files"
	"""
	files(
		"""
		distinct select on columns
		"""
		distinct_on: [files_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [files_order_by!]
		"""
		filter the rows returned
		"""
		where: files_bool_exp
	): [files!]!
	"""
	fetch data from the table: "kb_entries"
	"""
	kb_entries(
		"""
		distinct select on columns
		"""
		distinct_on: [kb_entries_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [kb_entries_order_by!]
		"""
		filter the rows returned
		"""
		where: kb_entries_bool_exp
	): [kb_entries!]!
	"""
	fetch data from the table: "kb_entries" using primary key columns
	"""
	kb_entries_by_pk(id: uuid!): kb_entries
	"""
	An array relationship
	"""
	kb_entry_departments(
		"""
		distinct select on columns
		"""
		distinct_on: [kb_entry_departments_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [kb_entry_departments_order_by!]
		"""
		filter the rows returned
		"""
		where: kb_entry_departments_bool_exp
	): [kb_entry_departments!]!
	"""
	fetch data from the table: "kb_entry_departments" using primary key columns
	"""
	kb_entry_departments_by_pk(id: uuid!): kb_entry_departments
	"""
	fetch data from the table: "auth.users" using primary key columns
	"""
	user(id: uuid!): users
	"""
	fetch data from the table: "user_departments"
	"""
	user_departments(
		"""
		distinct select on columns
		"""
		distinct_on: [user_departments_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [user_departments_order_by!]
		"""
		filter the rows returned
		"""
		where: user_departments_bool_exp
	): [user_departments!]!
	"""
	fetch data from the table: "user_departments" using primary key columns
	"""
	user_departments_by_pk(id: uuid!): user_departments
	"""
	fetch data from the table: "auth.users"
	"""
	users(
		"""
		distinct select on columns
		"""
		distinct_on: [users_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [users_order_by!]
		"""
		filter the rows returned
		"""
		where: users_bool_exp
	): [users!]!
}

type subscription_root {
	"""
	fetch data from the table: "auth.refresh_tokens" using primary key columns
	"""
	authRefreshToken(id: uuid!): authRefreshTokens
	"""
	fetch data from the table: "auth.refresh_tokens"
	"""
	authRefreshTokens(
		"""
		distinct select on columns
		"""
		distinct_on: [authRefreshTokens_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [authRefreshTokens_order_by!]
		"""
		filter the rows returned
		"""
		where: authRefreshTokens_bool_exp
	): [authRefreshTokens!]!
	"""
	fetch data from the table in a streaming manner: "auth.refresh_tokens"
	"""
	authRefreshTokens_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!
		"""
		cursor to stream the results returned by the query
		"""
		cursor: [authRefreshTokens_stream_cursor_input]!
		"""
		filter the rows returned
		"""
		where: authRefreshTokens_bool_exp
	): [authRefreshTokens!]!
	"""
	fetch data from the table: "auth.user_security_keys" using primary key columns
	"""
	authUserSecurityKey(id: uuid!): authUserSecurityKeys
	"""
	fetch data from the table: "auth.user_security_keys"
	"""
	authUserSecurityKeys(
		"""
		distinct select on columns
		"""
		distinct_on: [authUserSecurityKeys_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [authUserSecurityKeys_order_by!]
		"""
		filter the rows returned
		"""
		where: authUserSecurityKeys_bool_exp
	): [authUserSecurityKeys!]!
	"""
	fetch data from the table in a streaming manner: "auth.user_security_keys"
	"""
	authUserSecurityKeys_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!
		"""
		cursor to stream the results returned by the query
		"""
		cursor: [authUserSecurityKeys_stream_cursor_input]!
		"""
		filter the rows returned
		"""
		where: authUserSecurityKeys_bool_exp
	): [authUserSecurityKeys!]!
	"""
	fetch data from the table: "department_files"
	"""
	department_files(
		"""
		distinct select on columns
		"""
		distinct_on: [department_files_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [department_files_order_by!]
		"""
		filter the rows returned
		"""
		where: department_files_bool_exp
	): [department_files!]!
	"""
	fetch data from the table: "department_files" using primary key columns
	"""
	department_files_by_pk(id: uuid!): department_files
	"""
	fetch data from the table in a streaming manner: "department_files"
	"""
	department_files_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!
		"""
		cursor to stream the results returned by the query
		"""
		cursor: [department_files_stream_cursor_input]!
		"""
		filter the rows returned
		"""
		where: department_files_bool_exp
	): [department_files!]!
	"""
	fetch data from the table: "department_roles"
	"""
	department_roles(
		"""
		distinct select on columns
		"""
		distinct_on: [department_roles_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [department_roles_order_by!]
		"""
		filter the rows returned
		"""
		where: department_roles_bool_exp
	): [department_roles!]!
	"""
	fetch data from the table: "department_roles" using primary key columns
	"""
	department_roles_by_pk(value: String!): department_roles
	"""
	fetch data from the table in a streaming manner: "department_roles"
	"""
	department_roles_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!
		"""
		cursor to stream the results returned by the query
		"""
		cursor: [department_roles_stream_cursor_input]!
		"""
		filter the rows returned
		"""
		where: department_roles_bool_exp
	): [department_roles!]!
	"""
	fetch data from the table: "departments"
	"""
	departments(
		"""
		distinct select on columns
		"""
		distinct_on: [departments_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [departments_order_by!]
		"""
		filter the rows returned
		"""
		where: departments_bool_exp
	): [departments!]!
	"""
	fetch data from the table: "departments" using primary key columns
	"""
	departments_by_pk(id: uuid!): departments
	"""
	fetch data from the table in a streaming manner: "departments"
	"""
	departments_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!
		"""
		cursor to stream the results returned by the query
		"""
		cursor: [departments_stream_cursor_input]!
		"""
		filter the rows returned
		"""
		where: departments_bool_exp
	): [departments!]!
	"""
	fetch data from the table: "storage.files" using primary key columns
	"""
	file(id: uuid!): files
	"""
	fetch data from the table: "storage.files"
	"""
	files(
		"""
		distinct select on columns
		"""
		distinct_on: [files_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [files_order_by!]
		"""
		filter the rows returned
		"""
		where: files_bool_exp
	): [files!]!
	"""
	fetch data from the table in a streaming manner: "storage.files"
	"""
	files_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!
		"""
		cursor to stream the results returned by the query
		"""
		cursor: [files_stream_cursor_input]!
		"""
		filter the rows returned
		"""
		where: files_bool_exp
	): [files!]!
	"""
	fetch data from the table: "kb_entries"
	"""
	kb_entries(
		"""
		distinct select on columns
		"""
		distinct_on: [kb_entries_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [kb_entries_order_by!]
		"""
		filter the rows returned
		"""
		where: kb_entries_bool_exp
	): [kb_entries!]!
	"""
	fetch data from the table: "kb_entries" using primary key columns
	"""
	kb_entries_by_pk(id: uuid!): kb_entries
	"""
	fetch data from the table in a streaming manner: "kb_entries"
	"""
	kb_entries_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!
		"""
		cursor to stream the results returned by the query
		"""
		cursor: [kb_entries_stream_cursor_input]!
		"""
		filter the rows returned
		"""
		where: kb_entries_bool_exp
	): [kb_entries!]!
	"""
	An array relationship
	"""
	kb_entry_departments(
		"""
		distinct select on columns
		"""
		distinct_on: [kb_entry_departments_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [kb_entry_departments_order_by!]
		"""
		filter the rows returned
		"""
		where: kb_entry_departments_bool_exp
	): [kb_entry_departments!]!
	"""
	fetch data from the table: "kb_entry_departments" using primary key columns
	"""
	kb_entry_departments_by_pk(id: uuid!): kb_entry_departments
	"""
	fetch data from the table in a streaming manner: "kb_entry_departments"
	"""
	kb_entry_departments_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!
		"""
		cursor to stream the results returned by the query
		"""
		cursor: [kb_entry_departments_stream_cursor_input]!
		"""
		filter the rows returned
		"""
		where: kb_entry_departments_bool_exp
	): [kb_entry_departments!]!
	"""
	fetch data from the table: "auth.users" using primary key columns
	"""
	user(id: uuid!): users
	"""
	fetch data from the table: "user_departments"
	"""
	user_departments(
		"""
		distinct select on columns
		"""
		distinct_on: [user_departments_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [user_departments_order_by!]
		"""
		filter the rows returned
		"""
		where: user_departments_bool_exp
	): [user_departments!]!
	"""
	fetch data from the table: "user_departments" using primary key columns
	"""
	user_departments_by_pk(id: uuid!): user_departments
	"""
	fetch data from the table in a streaming manner: "user_departments"
	"""
	user_departments_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!
		"""
		cursor to stream the results returned by the query
		"""
		cursor: [user_departments_stream_cursor_input]!
		"""
		filter the rows returned
		"""
		where: user_departments_bool_exp
	): [user_departments!]!
	"""
	fetch data from the table: "auth.users"
	"""
	users(
		"""
		distinct select on columns
		"""
		distinct_on: [users_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [users_order_by!]
		"""
		filter the rows returned
		"""
		where: users_bool_exp
	): [users!]!
	"""
	fetch data from the table in a streaming manner: "auth.users"
	"""
	users_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!
		"""
		cursor to stream the results returned by the query
		"""
		cursor: [users_stream_cursor_input]!
		"""
		filter the rows returned
		"""
		where: users_bool_exp
	): [users!]!
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
	_eq: timestamptz
	_gt: timestamptz
	_gte: timestamptz
	_in: [timestamptz!]
	_is_null: Boolean
	_lt: timestamptz
	_lte: timestamptz
	_neq: timestamptz
	_nin: [timestamptz!]
}

"""
columns and relationships of "user_departments"
"""
type user_departments {
	"""
	An object relationship
	"""
	department: departments!
	department_id: uuid!
	id: uuid!
	is_active: Boolean!
	joined_at: timestamptz!
	role: department_roles_enum
	"""
	An object relationship
	"""
	user: users!
	user_id: uuid!
}

"""
order by aggregate values of table "user_departments"
"""
input user_departments_aggregate_order_by {
	count: order_by
	max: user_departments_max_order_by
	min: user_departments_min_order_by
}

"""
Boolean expression to filter rows from the table "user_departments". All fields are combined with a logical 'AND'.
"""
input user_departments_bool_exp {
	_and: [user_departments_bool_exp!]
	_not: user_departments_bool_exp
	_or: [user_departments_bool_exp!]
	department: departments_bool_exp
	department_id: uuid_comparison_exp
	id: uuid_comparison_exp
	is_active: Boolean_comparison_exp
	joined_at: timestamptz_comparison_exp
	role: department_roles_enum_comparison_exp
	user: users_bool_exp
	user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "user_departments"
"""
enum user_departments_constraint {
	"""
	unique or primary key constraint on columns "id"
	"""
	user_departments_pkey
	"""
	unique or primary key constraint on columns "user_id", "department_id"
	"""
	user_departments_user_id_department_id_key
}

"""
input type for inserting data into table "user_departments"
"""
input user_departments_insert_input {
	department_id: uuid
	is_active: Boolean
	role: department_roles_enum
	user_id: uuid
}

"""
order by max() on columns of table "user_departments"
"""
input user_departments_max_order_by {
	department_id: order_by
	id: order_by
	joined_at: order_by
	user_id: order_by
}

"""
order by min() on columns of table "user_departments"
"""
input user_departments_min_order_by {
	department_id: order_by
	id: order_by
	joined_at: order_by
	user_id: order_by
}

"""
response of any mutation on the table "user_departments"
"""
type user_departments_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!
	"""
	data from the rows affected by the mutation
	"""
	returning: [user_departments!]!
}

"""
on_conflict condition type for table "user_departments"
"""
input user_departments_on_conflict {
	constraint: user_departments_constraint!
	update_columns: [user_departments_update_column!]! = []
	where: user_departments_bool_exp
}

"""
Ordering options when selecting data from "user_departments".
"""
input user_departments_order_by {
	department: departments_order_by
	department_id: order_by
	id: order_by
	is_active: order_by
	joined_at: order_by
	role: order_by
	user: users_order_by
	user_id: order_by
}

"""
primary key columns input for table: user_departments
"""
input user_departments_pk_columns_input {
	id: uuid!
}

"""
select columns of table "user_departments"
"""
enum user_departments_select_column {
	"""
	column name
	"""
	department_id
	"""
	column name
	"""
	id
	"""
	column name
	"""
	is_active
	"""
	column name
	"""
	joined_at
	"""
	column name
	"""
	role
	"""
	column name
	"""
	user_id
}

"""
input type for updating data in table "user_departments"
"""
input user_departments_set_input {
	is_active: Boolean
	role: department_roles_enum
}

"""
Streaming cursor of the table "user_departments"
"""
input user_departments_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: user_departments_stream_cursor_value_input!
	"""
	cursor ordering
	"""
	ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input user_departments_stream_cursor_value_input {
	department_id: uuid
	id: uuid
	is_active: Boolean
	joined_at: timestamptz
	role: department_roles_enum
	user_id: uuid
}

"""
update columns of table "user_departments"
"""
enum user_departments_update_column {
	"""
	column name
	"""
	is_active
	"""
	column name
	"""
	role
}

input user_departments_updates {
	"""
	sets the columns of the filtered rows to the given values
	"""
	_set: user_departments_set_input
	"""
	filter the rows which have to be updated
	"""
	where: user_departments_bool_exp!
}

"""
User account information. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type users {
	avatarUrl: String!
	createdAt: timestamptz!
	"""
	An array relationship
	"""
	departments(
		"""
		distinct select on columns
		"""
		distinct_on: [user_departments_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [user_departments_order_by!]
		"""
		filter the rows returned
		"""
		where: user_departments_bool_exp
	): [user_departments!]!
	displayName: String!
	email: citext
	emailVerified: Boolean!
	id: uuid!
	locale: String!
	"""
	An array relationship
	"""
	refreshTokens(
		"""
		distinct select on columns
		"""
		distinct_on: [authRefreshTokens_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [authRefreshTokens_order_by!]
		"""
		filter the rows returned
		"""
		where: authRefreshTokens_bool_exp
	): [authRefreshTokens!]!
	"""
	An array relationship
	"""
	securityKeys(
		"""
		distinct select on columns
		"""
		distinct_on: [authUserSecurityKeys_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [authUserSecurityKeys_order_by!]
		"""
		filter the rows returned
		"""
		where: authUserSecurityKeys_bool_exp
	): [authUserSecurityKeys!]!
	updatedAt: timestamptz!
}

"""
Boolean expression to filter rows from the table "auth.users". All fields are combined with a logical 'AND'.
"""
input users_bool_exp {
	_and: [users_bool_exp!]
	_not: users_bool_exp
	_or: [users_bool_exp!]
	avatarUrl: String_comparison_exp
	createdAt: timestamptz_comparison_exp
	departments: user_departments_bool_exp
	displayName: String_comparison_exp
	email: citext_comparison_exp
	emailVerified: Boolean_comparison_exp
	id: uuid_comparison_exp
	locale: String_comparison_exp
	refreshTokens: authRefreshTokens_bool_exp
	securityKeys: authUserSecurityKeys_bool_exp
	updatedAt: timestamptz_comparison_exp
}

"""
response of any mutation on the table "auth.users"
"""
type users_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!
	"""
	data from the rows affected by the mutation
	"""
	returning: [users!]!
}

"""
Ordering options when selecting data from "auth.users".
"""
input users_order_by {
	avatarUrl: order_by
	createdAt: order_by
	departments_aggregate: user_departments_aggregate_order_by
	displayName: order_by
	email: order_by
	emailVerified: order_by
	id: order_by
	locale: order_by
	refreshTokens_aggregate: authRefreshTokens_aggregate_order_by
	securityKeys_aggregate: authUserSecurityKeys_aggregate_order_by
	updatedAt: order_by
}

"""
primary key columns input for table: auth.users
"""
input users_pk_columns_input {
	id: uuid!
}

"""
select columns of table "auth.users"
"""
enum users_select_column {
	"""
	column name
	"""
	avatarUrl
	"""
	column name
	"""
	createdAt
	"""
	column name
	"""
	displayName
	"""
	column name
	"""
	email
	"""
	column name
	"""
	emailVerified
	"""
	column name
	"""
	id
	"""
	column name
	"""
	locale
	"""
	column name
	"""
	updatedAt
}

"""
input type for updating data in table "auth.users"
"""
input users_set_input {
	avatarUrl: String
	displayName: String
	locale: String
}

"""
Streaming cursor of the table "users"
"""
input users_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: users_stream_cursor_value_input!
	"""
	cursor ordering
	"""
	ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input users_stream_cursor_value_input {
	avatarUrl: String
	createdAt: timestamptz
	displayName: String
	email: citext
	emailVerified: Boolean
	id: uuid
	locale: String
	updatedAt: timestamptz
}

input users_updates {
	"""
	sets the columns of the filtered rows to the given values
	"""
	_set: users_set_input
	"""
	filter the rows which have to be updated
	"""
	where: users_bool_exp!
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
	_eq: uuid
	_gt: uuid
	_gte: uuid
	_in: [uuid!]
	_is_null: Boolean
	_lt: uuid
	_lte: uuid
	_neq: uuid
	_nin: [uuid!]
}
