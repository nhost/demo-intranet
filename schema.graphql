schema {
	query: query_root
	mutation: mutation_root
	subscription: subscription_root
}

"""
whether this query should be cached (Hasura Cloud only)
"""
directive @cached(
	"""
	refresh the cache entry
	"""
	refresh: Boolean! = false
	"""
	measured in seconds
	"""
	ttl: Int! = 60
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
	_eq: Boolean
	_gt: Boolean
	_gte: Boolean
	_in: [Boolean!]
	_is_null: Boolean
	_lt: Boolean
	_lte: Boolean
	_neq: Boolean
	_nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
	_eq: Int
	_gt: Int
	_gte: Int
	_in: [Int!]
	_is_null: Boolean
	_lt: Int
	_lte: Int
	_neq: Int
	_nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
	_eq: String
	_gt: String
	_gte: String
	"""
	does the column match the given case-insensitive pattern
	"""
	_ilike: String
	_in: [String!]
	"""
	does the column match the given POSIX regular expression, case insensitive
	"""
	_iregex: String
	_is_null: Boolean
	"""
	does the column match the given pattern
	"""
	_like: String
	_lt: String
	_lte: String
	_neq: String
	"""
	does the column NOT match the given case-insensitive pattern
	"""
	_nilike: String
	_nin: [String!]
	"""
	does the column NOT match the given POSIX regular expression, case insensitive
	"""
	_niregex: String
	"""
	does the column NOT match the given pattern
	"""
	_nlike: String
	"""
	does the column NOT match the given POSIX regular expression, case sensitive
	"""
	_nregex: String
	"""
	does the column NOT match the given SQL regular expression
	"""
	_nsimilar: String
	"""
	does the column match the given POSIX regular expression, case sensitive
	"""
	_regex: String
	"""
	does the column match the given SQL regular expression
	"""
	_similar: String
}

enum authRefreshTokenTypes_enum {
	"""
	Personal access token
	"""
	pat
	"""
	Regular refresh token
	"""
	regular
}

"""
Boolean expression to compare columns of type "authRefreshTokenTypes_enum". All fields are combined with logical 'AND'.
"""
input authRefreshTokenTypes_enum_comparison_exp {
	_eq: authRefreshTokenTypes_enum
	_in: [authRefreshTokenTypes_enum!]
	_is_null: Boolean
	_neq: authRefreshTokenTypes_enum
	_nin: [authRefreshTokenTypes_enum!]
}

"""
User refresh tokens. Hasura auth uses them to rotate new access tokens as long as the refresh token is not expired. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authRefreshTokens {
	createdAt: timestamptz!
	expiresAt: timestamptz!
	id: uuid!
	metadata(
		"""
		JSON select path
		"""
		path: String
	): jsonb
	type: authRefreshTokenTypes_enum!
	"""
	An object relationship
	"""
	user: users!
	userId: uuid!
}

"""
order by aggregate values of table "auth.refresh_tokens"
"""
input authRefreshTokens_aggregate_order_by {
	count: order_by
	max: authRefreshTokens_max_order_by
	min: authRefreshTokens_min_order_by
}

"""
Boolean expression to filter rows from the table "auth.refresh_tokens". All fields are combined with a logical 'AND'.
"""
input authRefreshTokens_bool_exp {
	_and: [authRefreshTokens_bool_exp!]
	_not: authRefreshTokens_bool_exp
	_or: [authRefreshTokens_bool_exp!]
	createdAt: timestamptz_comparison_exp
	expiresAt: timestamptz_comparison_exp
	id: uuid_comparison_exp
	metadata: jsonb_comparison_exp
	type: authRefreshTokenTypes_enum_comparison_exp
	user: users_bool_exp
	userId: uuid_comparison_exp
}

"""
order by max() on columns of table "auth.refresh_tokens"
"""
input authRefreshTokens_max_order_by {
	createdAt: order_by
	expiresAt: order_by
	id: order_by
	userId: order_by
}

"""
order by min() on columns of table "auth.refresh_tokens"
"""
input authRefreshTokens_min_order_by {
	createdAt: order_by
	expiresAt: order_by
	id: order_by
	userId: order_by
}

"""
response of any mutation on the table "auth.refresh_tokens"
"""
type authRefreshTokens_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!
	"""
	data from the rows affected by the mutation
	"""
	returning: [authRefreshTokens!]!
}

"""
Ordering options when selecting data from "auth.refresh_tokens".
"""
input authRefreshTokens_order_by {
	createdAt: order_by
	expiresAt: order_by
	id: order_by
	metadata: order_by
	type: order_by
	user: users_order_by
	userId: order_by
}

"""
select columns of table "auth.refresh_tokens"
"""
enum authRefreshTokens_select_column {
	"""
	column name
	"""
	createdAt
	"""
	column name
	"""
	expiresAt
	"""
	column name
	"""
	id
	"""
	column name
	"""
	metadata
	"""
	column name
	"""
	type
	"""
	column name
	"""
	userId
}

"""
Streaming cursor of the table "authRefreshTokens"
"""
input authRefreshTokens_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: authRefreshTokens_stream_cursor_value_input!
	"""
	cursor ordering
	"""
	ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input authRefreshTokens_stream_cursor_value_input {
	createdAt: timestamptz
	expiresAt: timestamptz
	id: uuid
	metadata: jsonb
	type: authRefreshTokenTypes_enum
	userId: uuid
}

"""
User webauthn security keys. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authUserSecurityKeys {
	counter: bigint!
	credentialId: String!
	credentialPublicKey: bytea
	id: uuid!
	nickname: String
	transports: String!
	"""
	An object relationship
	"""
	user: users!
	userId: uuid!
}

"""
order by aggregate values of table "auth.user_security_keys"
"""
input authUserSecurityKeys_aggregate_order_by {
	avg: authUserSecurityKeys_avg_order_by
	count: order_by
	max: authUserSecurityKeys_max_order_by
	min: authUserSecurityKeys_min_order_by
	stddev: authUserSecurityKeys_stddev_order_by
	stddev_pop: authUserSecurityKeys_stddev_pop_order_by
	stddev_samp: authUserSecurityKeys_stddev_samp_order_by
	sum: authUserSecurityKeys_sum_order_by
	var_pop: authUserSecurityKeys_var_pop_order_by
	var_samp: authUserSecurityKeys_var_samp_order_by
	variance: authUserSecurityKeys_variance_order_by
}

"""
order by avg() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_avg_order_by {
	counter: order_by
}

"""
Boolean expression to filter rows from the table "auth.user_security_keys". All fields are combined with a logical 'AND'.
"""
input authUserSecurityKeys_bool_exp {
	_and: [authUserSecurityKeys_bool_exp!]
	_not: authUserSecurityKeys_bool_exp
	_or: [authUserSecurityKeys_bool_exp!]
	counter: bigint_comparison_exp
	credentialId: String_comparison_exp
	credentialPublicKey: bytea_comparison_exp
	id: uuid_comparison_exp
	nickname: String_comparison_exp
	transports: String_comparison_exp
	user: users_bool_exp
	userId: uuid_comparison_exp
}

"""
order by max() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_max_order_by {
	counter: order_by
	credentialId: order_by
	id: order_by
	nickname: order_by
	transports: order_by
	userId: order_by
}

"""
order by min() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_min_order_by {
	counter: order_by
	credentialId: order_by
	id: order_by
	nickname: order_by
	transports: order_by
	userId: order_by
}

"""
response of any mutation on the table "auth.user_security_keys"
"""
type authUserSecurityKeys_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!
	"""
	data from the rows affected by the mutation
	"""
	returning: [authUserSecurityKeys!]!
}

"""
Ordering options when selecting data from "auth.user_security_keys".
"""
input authUserSecurityKeys_order_by {
	counter: order_by
	credentialId: order_by
	credentialPublicKey: order_by
	id: order_by
	nickname: order_by
	transports: order_by
	user: users_order_by
	userId: order_by
}

"""
select columns of table "auth.user_security_keys"
"""
enum authUserSecurityKeys_select_column {
	"""
	column name
	"""
	counter
	"""
	column name
	"""
	credentialId
	"""
	column name
	"""
	credentialPublicKey
	"""
	column name
	"""
	id
	"""
	column name
	"""
	nickname
	"""
	column name
	"""
	transports
	"""
	column name
	"""
	userId
}

"""
order by stddev() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_stddev_order_by {
	counter: order_by
}

"""
order by stddev_pop() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_stddev_pop_order_by {
	counter: order_by
}

"""
order by stddev_samp() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_stddev_samp_order_by {
	counter: order_by
}

"""
Streaming cursor of the table "authUserSecurityKeys"
"""
input authUserSecurityKeys_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: authUserSecurityKeys_stream_cursor_value_input!
	"""
	cursor ordering
	"""
	ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input authUserSecurityKeys_stream_cursor_value_input {
	counter: bigint
	credentialId: String
	credentialPublicKey: bytea
	id: uuid
	nickname: String
	transports: String
	userId: uuid
}

"""
order by sum() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_sum_order_by {
	counter: order_by
}

"""
order by var_pop() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_var_pop_order_by {
	counter: order_by
}

"""
order by var_samp() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_var_samp_order_by {
	counter: order_by
}

"""
order by variance() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_variance_order_by {
	counter: order_by
}

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
	_eq: bigint
	_gt: bigint
	_gte: bigint
	_in: [bigint!]
	_is_null: Boolean
	_lt: bigint
	_lte: bigint
	_neq: bigint
	_nin: [bigint!]
}

scalar bytea

"""
Boolean expression to compare columns of type "bytea". All fields are combined with logical 'AND'.
"""
input bytea_comparison_exp {
	_eq: bytea
	_gt: bytea
	_gte: bytea
	_in: [bytea!]
	_is_null: Boolean
	_lt: bytea
	_lte: bytea
	_neq: bytea
	_nin: [bytea!]
}

scalar citext

"""
Boolean expression to compare columns of type "citext". All fields are combined with logical 'AND'.
"""
input citext_comparison_exp {
	_eq: citext
	_gt: citext
	_gte: citext
	"""
	does the column match the given case-insensitive pattern
	"""
	_ilike: citext
	_in: [citext!]
	"""
	does the column match the given POSIX regular expression, case insensitive
	"""
	_iregex: citext
	_is_null: Boolean
	"""
	does the column match the given pattern
	"""
	_like: citext
	_lt: citext
	_lte: citext
	_neq: citext
	"""
	does the column NOT match the given case-insensitive pattern
	"""
	_nilike: citext
	_nin: [citext!]
	"""
	does the column NOT match the given POSIX regular expression, case insensitive
	"""
	_niregex: citext
	"""
	does the column NOT match the given pattern
	"""
	_nlike: citext
	"""
	does the column NOT match the given POSIX regular expression, case sensitive
	"""
	_nregex: citext
	"""
	does the column NOT match the given SQL regular expression
	"""
	_nsimilar: citext
	"""
	does the column match the given POSIX regular expression, case sensitive
	"""
	_regex: citext
	"""
	does the column match the given SQL regular expression
	"""
	_similar: citext
}

"""
ordering argument of a cursor
"""
enum cursor_ordering {
	"""
	ascending ordering of the cursor
	"""
	ASC
	"""
	descending ordering of the cursor
	"""
	DESC
}

"""
columns and relationships of "storage.files"
"""
type files {
	bucketId: String!
	createdAt: timestamptz!
	etag: String
	id: uuid!
	isUploaded: Boolean
	metadata(
		"""
		JSON select path
		"""
		path: String
	): jsonb
	mimeType: String
	name: String
	size: Int
	updatedAt: timestamptz!
	uploadedByUserId: uuid
}

"""
Boolean expression to filter rows from the table "storage.files". All fields are combined with a logical 'AND'.
"""
input files_bool_exp {
	_and: [files_bool_exp!]
	_not: files_bool_exp
	_or: [files_bool_exp!]
	bucketId: String_comparison_exp
	createdAt: timestamptz_comparison_exp
	etag: String_comparison_exp
	id: uuid_comparison_exp
	isUploaded: Boolean_comparison_exp
	metadata: jsonb_comparison_exp
	mimeType: String_comparison_exp
	name: String_comparison_exp
	size: Int_comparison_exp
	updatedAt: timestamptz_comparison_exp
	uploadedByUserId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "storage.files"
"""
enum files_constraint {
	"""
	unique or primary key constraint on columns "id"
	"""
	files_pkey
}

"""
input type for inserting data into table "storage.files"
"""
input files_insert_input {
	bucketId: String
	id: uuid
	metadata: jsonb
	mimeType: String
	name: String
	size: Int
}

"""
response of any mutation on the table "storage.files"
"""
type files_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!
	"""
	data from the rows affected by the mutation
	"""
	returning: [files!]!
}

"""
on_conflict condition type for table "storage.files"
"""
input files_on_conflict {
	constraint: files_constraint!
	update_columns: [files_update_column!]! = []
	where: files_bool_exp
}

"""
Ordering options when selecting data from "storage.files".
"""
input files_order_by {
	bucketId: order_by
	createdAt: order_by
	etag: order_by
	id: order_by
	isUploaded: order_by
	metadata: order_by
	mimeType: order_by
	name: order_by
	size: order_by
	updatedAt: order_by
	uploadedByUserId: order_by
}

"""
select columns of table "storage.files"
"""
enum files_select_column {
	"""
	column name
	"""
	bucketId
	"""
	column name
	"""
	createdAt
	"""
	column name
	"""
	etag
	"""
	column name
	"""
	id
	"""
	column name
	"""
	isUploaded
	"""
	column name
	"""
	metadata
	"""
	column name
	"""
	mimeType
	"""
	column name
	"""
	name
	"""
	column name
	"""
	size
	"""
	column name
	"""
	updatedAt
	"""
	column name
	"""
	uploadedByUserId
}

"""
Streaming cursor of the table "files"
"""
input files_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: files_stream_cursor_value_input!
	"""
	cursor ordering
	"""
	ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input files_stream_cursor_value_input {
	bucketId: String
	createdAt: timestamptz
	etag: String
	id: uuid
	isUploaded: Boolean
	metadata: jsonb
	mimeType: String
	name: String
	size: Int
	updatedAt: timestamptz
	uploadedByUserId: uuid
}

"""
placeholder for update columns of table "storage.files" (current role has no relevant permissions)
"""
enum files_update_column {
	"""
	placeholder (do not use)
	"""
	_PLACEHOLDER
}

scalar jsonb

input jsonb_cast_exp {
	String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
	_cast: jsonb_cast_exp
	"""
	is the column contained in the given json value
	"""
	_contained_in: jsonb
	"""
	does the column contain the given json value at the top level
	"""
	_contains: jsonb
	_eq: jsonb
	_gt: jsonb
	_gte: jsonb
	"""
	does the string exist as a top-level key in the column
	"""
	_has_key: String
	"""
	do all of these strings exist as top-level keys in the column
	"""
	_has_keys_all: [String!]
	"""
	do any of these strings exist as top-level keys in the column
	"""
	_has_keys_any: [String!]
	_in: [jsonb!]
	_is_null: Boolean
	_lt: jsonb
	_lte: jsonb
	_neq: jsonb
	_nin: [jsonb!]
}

"""
mutation root
"""
type mutation_root {
	"""
	delete single row from the table: "auth.refresh_tokens"
	"""
	deleteAuthRefreshToken(id: uuid!): authRefreshTokens
	"""
	delete data from the table: "auth.refresh_tokens"
	"""
	deleteAuthRefreshTokens(
		"""
		filter the rows which have to be deleted
		"""
		where: authRefreshTokens_bool_exp!
	): authRefreshTokens_mutation_response
	"""
	delete single row from the table: "auth.user_security_keys"
	"""
	deleteAuthUserSecurityKey(id: uuid!): authUserSecurityKeys
	"""
	delete data from the table: "auth.user_security_keys"
	"""
	deleteAuthUserSecurityKeys(
		"""
		filter the rows which have to be deleted
		"""
		where: authUserSecurityKeys_bool_exp!
	): authUserSecurityKeys_mutation_response
	"""
	insert a single row into the table: "storage.files"
	"""
	insertFile(
		"""
		the row to be inserted
		"""
		object: files_insert_input!
		"""
		upsert condition
		"""
		on_conflict: files_on_conflict
	): files
	"""
	insert data into the table: "storage.files"
	"""
	insertFiles(
		"""
		the rows to be inserted
		"""
		objects: [files_insert_input!]!
		"""
		upsert condition
		"""
		on_conflict: files_on_conflict
	): files_mutation_response
	"""
	update single row of the table: "auth.users"
	"""
	updateUser(
		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: users_set_input
		pk_columns: users_pk_columns_input!
	): users
	"""
	update data of the table: "auth.users"
	"""
	updateUsers(
		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: users_set_input
		"""
		filter the rows which have to be updated
		"""
		where: users_bool_exp!
	): users_mutation_response
	"""
	update multiples rows of table: "auth.users"
	"""
	update_users_many(
		"""
		updates to execute, in order
		"""
		updates: [users_updates!]!
	): [users_mutation_response]
}

"""
column ordering options
"""
enum order_by {
	"""
	in ascending order, nulls last
	"""
	asc
	"""
	in ascending order, nulls first
	"""
	asc_nulls_first
	"""
	in ascending order, nulls last
	"""
	asc_nulls_last
	"""
	in descending order, nulls first
	"""
	desc
	"""
	in descending order, nulls first
	"""
	desc_nulls_first
	"""
	in descending order, nulls last
	"""
	desc_nulls_last
}

type query_root {
	"""
	fetch data from the table: "auth.refresh_tokens" using primary key columns
	"""
	authRefreshToken(id: uuid!): authRefreshTokens
	"""
	fetch data from the table: "auth.refresh_tokens"
	"""
	authRefreshTokens(
		"""
		distinct select on columns
		"""
		distinct_on: [authRefreshTokens_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [authRefreshTokens_order_by!]
		"""
		filter the rows returned
		"""
		where: authRefreshTokens_bool_exp
	): [authRefreshTokens!]!
	"""
	fetch data from the table: "auth.user_security_keys" using primary key columns
	"""
	authUserSecurityKey(id: uuid!): authUserSecurityKeys
	"""
	fetch data from the table: "auth.user_security_keys"
	"""
	authUserSecurityKeys(
		"""
		distinct select on columns
		"""
		distinct_on: [authUserSecurityKeys_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [authUserSecurityKeys_order_by!]
		"""
		filter the rows returned
		"""
		where: authUserSecurityKeys_bool_exp
	): [authUserSecurityKeys!]!
	"""
	fetch data from the table: "storage.files" using primary key columns
	"""
	file(id: uuid!): files
	"""
	fetch data from the table: "storage.files"
	"""
	files(
		"""
		distinct select on columns
		"""
		distinct_on: [files_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [files_order_by!]
		"""
		filter the rows returned
		"""
		where: files_bool_exp
	): [files!]!
	"""
	fetch data from the table: "auth.users" using primary key columns
	"""
	user(id: uuid!): users
	"""
	fetch data from the table: "auth.users"
	"""
	users(
		"""
		distinct select on columns
		"""
		distinct_on: [users_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [users_order_by!]
		"""
		filter the rows returned
		"""
		where: users_bool_exp
	): [users!]!
}

type subscription_root {
	"""
	fetch data from the table: "auth.refresh_tokens" using primary key columns
	"""
	authRefreshToken(id: uuid!): authRefreshTokens
	"""
	fetch data from the table: "auth.refresh_tokens"
	"""
	authRefreshTokens(
		"""
		distinct select on columns
		"""
		distinct_on: [authRefreshTokens_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [authRefreshTokens_order_by!]
		"""
		filter the rows returned
		"""
		where: authRefreshTokens_bool_exp
	): [authRefreshTokens!]!
	"""
	fetch data from the table in a streaming manner: "auth.refresh_tokens"
	"""
	authRefreshTokens_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!
		"""
		cursor to stream the results returned by the query
		"""
		cursor: [authRefreshTokens_stream_cursor_input]!
		"""
		filter the rows returned
		"""
		where: authRefreshTokens_bool_exp
	): [authRefreshTokens!]!
	"""
	fetch data from the table: "auth.user_security_keys" using primary key columns
	"""
	authUserSecurityKey(id: uuid!): authUserSecurityKeys
	"""
	fetch data from the table: "auth.user_security_keys"
	"""
	authUserSecurityKeys(
		"""
		distinct select on columns
		"""
		distinct_on: [authUserSecurityKeys_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [authUserSecurityKeys_order_by!]
		"""
		filter the rows returned
		"""
		where: authUserSecurityKeys_bool_exp
	): [authUserSecurityKeys!]!
	"""
	fetch data from the table in a streaming manner: "auth.user_security_keys"
	"""
	authUserSecurityKeys_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!
		"""
		cursor to stream the results returned by the query
		"""
		cursor: [authUserSecurityKeys_stream_cursor_input]!
		"""
		filter the rows returned
		"""
		where: authUserSecurityKeys_bool_exp
	): [authUserSecurityKeys!]!
	"""
	fetch data from the table: "storage.files" using primary key columns
	"""
	file(id: uuid!): files
	"""
	fetch data from the table: "storage.files"
	"""
	files(
		"""
		distinct select on columns
		"""
		distinct_on: [files_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [files_order_by!]
		"""
		filter the rows returned
		"""
		where: files_bool_exp
	): [files!]!
	"""
	fetch data from the table in a streaming manner: "storage.files"
	"""
	files_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!
		"""
		cursor to stream the results returned by the query
		"""
		cursor: [files_stream_cursor_input]!
		"""
		filter the rows returned
		"""
		where: files_bool_exp
	): [files!]!
	"""
	fetch data from the table: "auth.users" using primary key columns
	"""
	user(id: uuid!): users
	"""
	fetch data from the table: "auth.users"
	"""
	users(
		"""
		distinct select on columns
		"""
		distinct_on: [users_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [users_order_by!]
		"""
		filter the rows returned
		"""
		where: users_bool_exp
	): [users!]!
	"""
	fetch data from the table in a streaming manner: "auth.users"
	"""
	users_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!
		"""
		cursor to stream the results returned by the query
		"""
		cursor: [users_stream_cursor_input]!
		"""
		filter the rows returned
		"""
		where: users_bool_exp
	): [users!]!
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
	_eq: timestamptz
	_gt: timestamptz
	_gte: timestamptz
	_in: [timestamptz!]
	_is_null: Boolean
	_lt: timestamptz
	_lte: timestamptz
	_neq: timestamptz
	_nin: [timestamptz!]
}

"""
User account information. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type users {
	avatarUrl: String!
	createdAt: timestamptz!
	displayName: String!
	email: citext
	emailVerified: Boolean!
	id: uuid!
	locale: String!
	"""
	An array relationship
	"""
	refreshTokens(
		"""
		distinct select on columns
		"""
		distinct_on: [authRefreshTokens_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [authRefreshTokens_order_by!]
		"""
		filter the rows returned
		"""
		where: authRefreshTokens_bool_exp
	): [authRefreshTokens!]!
	"""
	An array relationship
	"""
	securityKeys(
		"""
		distinct select on columns
		"""
		distinct_on: [authUserSecurityKeys_select_column!]
		"""
		limit the number of rows returned
		"""
		limit: Int
		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int
		"""
		sort the rows by one or more columns
		"""
		order_by: [authUserSecurityKeys_order_by!]
		"""
		filter the rows returned
		"""
		where: authUserSecurityKeys_bool_exp
	): [authUserSecurityKeys!]!
	updatedAt: timestamptz!
}

"""
Boolean expression to filter rows from the table "auth.users". All fields are combined with a logical 'AND'.
"""
input users_bool_exp {
	_and: [users_bool_exp!]
	_not: users_bool_exp
	_or: [users_bool_exp!]
	avatarUrl: String_comparison_exp
	createdAt: timestamptz_comparison_exp
	displayName: String_comparison_exp
	email: citext_comparison_exp
	emailVerified: Boolean_comparison_exp
	id: uuid_comparison_exp
	locale: String_comparison_exp
	refreshTokens: authRefreshTokens_bool_exp
	securityKeys: authUserSecurityKeys_bool_exp
	updatedAt: timestamptz_comparison_exp
}

"""
response of any mutation on the table "auth.users"
"""
type users_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!
	"""
	data from the rows affected by the mutation
	"""
	returning: [users!]!
}

"""
Ordering options when selecting data from "auth.users".
"""
input users_order_by {
	avatarUrl: order_by
	createdAt: order_by
	displayName: order_by
	email: order_by
	emailVerified: order_by
	id: order_by
	locale: order_by
	refreshTokens_aggregate: authRefreshTokens_aggregate_order_by
	securityKeys_aggregate: authUserSecurityKeys_aggregate_order_by
	updatedAt: order_by
}

"""
primary key columns input for table: auth.users
"""
input users_pk_columns_input {
	id: uuid!
}

"""
select columns of table "auth.users"
"""
enum users_select_column {
	"""
	column name
	"""
	avatarUrl
	"""
	column name
	"""
	createdAt
	"""
	column name
	"""
	displayName
	"""
	column name
	"""
	email
	"""
	column name
	"""
	emailVerified
	"""
	column name
	"""
	id
	"""
	column name
	"""
	locale
	"""
	column name
	"""
	updatedAt
}

"""
input type for updating data in table "auth.users"
"""
input users_set_input {
	avatarUrl: String
	displayName: String
	locale: String
}

"""
Streaming cursor of the table "users"
"""
input users_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: users_stream_cursor_value_input!
	"""
	cursor ordering
	"""
	ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input users_stream_cursor_value_input {
	avatarUrl: String
	createdAt: timestamptz
	displayName: String
	email: citext
	emailVerified: Boolean
	id: uuid
	locale: String
	updatedAt: timestamptz
}

input users_updates {
	"""
	sets the columns of the filtered rows to the given values
	"""
	_set: users_set_input
	"""
	filter the rows which have to be updated
	"""
	where: users_bool_exp!
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
	_eq: uuid
	_gt: uuid
	_gte: uuid
	_in: [uuid!]
	_is_null: Boolean
	_lt: uuid
	_lte: uuid
	_neq: uuid
	_nin: [uuid!]
}
