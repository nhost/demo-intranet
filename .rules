# Intranet - Project Rules

This project has specific architectural requirements and conventions that must be followed strictly.

## IMPORTANT NOTE FOR LLMs

When making significant architectural changes, adding new patterns, or modifying project structure, YOU MUST update this .rules file to reflect those changes. Also update the PROJECT_INDEX.md file to maintain accurate component and structure documentation. This ensures consistency for future development work.

## Project Purpose & Context

Always consider the educational context when suggesting features or implementations. Prioritize user experience and accessibility for language learners. Consider internationalization (i18n) requirements for multi-language support.

## Backend Architecture - Nhost Integration

NEVER directly modify Nhost configuration files (nhost.toml, .env.example, etc.) unless explicitly requested.

ALL database schema changes MUST be done through Nhost migrations using the Nhost CLI.

Use Nhost's MCP tools for all backend operations including:
- Database migrations via `local-manage-graphql` with /apis/migrate endpoint
- GraphQL metadata changes via `local-manage-graphql` with /v1/metadata endpoint
- Configuration changes via `local-config-server-query`
- Schema introspection via `local-get-graphql-schema` and `local-get-management-graphql-schema`

Always check current database state before making schema changes. Provide both up and down migrations for all database changes. Track new tables and foreign key relationships after creation. Use bulk metadata operations to avoid multiple requests. For role-based access, add roles via migrations to auth.roles table.

### Nhost SDK Documentation

This project uses a BETA version of the Nhost SDK. Model knowledge may be outdated for SDK usage patterns, API methods, and implementation details. ALWAYS reference the local documentation in `nhost/docs/` when working with the Nhost SDK to ensure accuracy with the current beta version. Check the documentation for:
- SDK initialization and configuration
- Authentication patterns and hooks
- GraphQL client usage
- Real-time subscriptions
- Storage and file upload patterns
- Functions and serverless patterns

## Package Manager - Bun

Use Bun as the JavaScript runtime and package manager:
- Use `bun install` for adding dependencies, not npm or yarn
- Use `bun add` for adding new packages
- Use `bun run` for executing scripts defined in package.json
- Leverage Bun's built-in APIs when possible (Bun.file, Bun.serve, etc.)
- Use `bun --hot` for development with hot reloading
- Reference bunfig.toml for Bun-specific configuration

## Code Quality - Biome

Follow Biome configuration in biome.jsonc for linting and formatting:
- Use tab indentation (as configured in Biome)
- Use double quotes for JavaScript/TypeScript strings
- Run `bun run check` to lint and format code
- All rules are enabled ('all': true), so follow strict code quality standards
- Organize imports automatically as configured

## Frontend Stack - React 19 + TypeScript

Use React 19 features and patterns with TypeScript for all new files. Leverage React's concurrent features when appropriate. Use React.StrictMode in development. Follow the configured path aliases in tsconfig.json (@/* for ./src/*). Use 'react-jsx' transform (no need to import React in every file).

## UI Framework - shadcn/ui + Tailwind CSS

Use shadcn/ui components from @/components/ui directory with Tailwind CSS v4:
- Follow the 'new-york' style variant as configured
- Use Tailwind CSS v4 classes for styling
- Leverage CSS variables for theming (cssVariables: true)
- Use 'zinc' as the base color scheme
- Use Lucide React for icons
- Follow the configured aliases:
  - @/components for components
  - @/lib/utils for utilities
  - @/components/ui for UI components
  - @/lib for libraries
  - @/hooks for custom hooks
- Use class-variance-authority (cva) for component variants
- Use clsx and tailwind-merge for conditional classes
- Implement animations with tailwindcss-animate

## Data Fetching - React Query

Use @tanstack/react-query for all data fetching and state management:
- Use queryKeys factory for consistent cache key management
- Implement proper loading and error states with React Query hooks
- Use mutations for data updates with optimistic updates where appropriate
- Configure appropriate staleTime and gcTime for different data types
- Use React Query DevTools in development for debugging
- Clear cache on sign out and handle authentication state changes
- Follow React Query best practices for background refetching and retry logic

## Routing - React Router

Use React Router DOM v7 for client-side routing:
- Use BrowserRouter as the main router wrapper
- Implement route protection with ProtectedLayout for nested protected routes
- Use Navigate component for redirects
- Define routes in App.tsx with clear path structure
- Handle 404s with catch-all route redirecting to home

## Form Management

Use react-hook-form for form state management with Zod schemas for validation. Use @hookform/resolvers for Zod integration. Create reusable form components following shadcn/ui patterns.

## Development Workflow

Use `bun dev` for development server with hot reloading. Use `bun build` for production builds.

Follow the existing directory structure:
- src/ for all source code
- src/components/ for React components
- src/components/ui/ for shadcn/ui components
- src/lib/ for utility functions and context providers
- src/lib/graphql/ for GraphQL operations and generated code
- styles/ for global styles
- nhost/ for backend configuration and documentation
- functions/ for serverless functions

Keep global styles in styles/globals.css. Use TypeScript strict mode patterns. Test GraphQL operations with appropriate roles (default to 'user' role unless specified). Reference PROJECT_INDEX.md for detailed component and structure information.

## Database and API Patterns

Always retrieve GraphQL schema before writing queries if schema might have changed. Use appropriate roles when testing GraphQL operations. Follow Hasura naming conventions for database tables and columns. Use snake_case for database columns and camelCase for GraphQL fields. Implement proper error handling for GraphQL operations. Use Nhost's built-in authentication and authorization patterns. Integrate GraphQL operations with React Query for caching and state management.

## Context Providers and State Management

Use React Context for application-wide state:
- AuthProvider for authentication state management with session handling
- ThemeProvider for light/dark theme management with persistence
- Wrap providers in proper order in App.tsx (Theme -> Query -> Auth -> Router)
- Use custom hooks (useAuth, useTheme) to access context values
- Clear React Query cache on authentication state changes

## File Naming and Organization

Use PascalCase for React component files (e.g., UserProfile.tsx). Use camelCase for utility files and hooks (e.g., useAuth.ts). Use kebab-case for route/page files if applicable. Group related components in subdirectories. Keep component files focused and single-responsibility. Co-locate component-specific types and utilities when appropriate.

## GraphQL Code Generation

Use GraphQL Codegen for type safety:
- Define operations in src/lib/graphql/operations.graphql
- Run `bun run build:codegen` or `./codegen.sh` after changes
- Generated types are placed in src/lib/graphql/__generated__/
- Create custom query hooks in src/lib/graphql/query-hooks.ts
- Integrate generated hooks with React Query for caching and state management

## Project Documentation

Maintain accurate documentation:
- Update PROJECT_INDEX.md when adding components or changing structure
- Update this .rules file when architectural patterns change
- Document component purposes, features, and dependencies in PROJECT_INDEX.md
- Keep README.md updated with basic setup and development instructions
